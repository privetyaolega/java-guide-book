package com.eis.conspect.java.se.multithreading.volatilee;

public class Volatile {

    /**
     *
     * volatile (подверженный изменению) - эта переменная может быть изменена
     * гарантирует когеретность кэшей. переменная не будет кэшироваться в кэш ядра.
     * переменная будет находится в главной памяти. поток будет обращаться к главной памяти
     *
     *
     *
     *
     * Атомареность (atomicity)
     *
     * Операция атомарна, если невозможно наблюдать частичный результат её выполнения.
     * Любой наблюдатель видит либо состояние системы до атомарной операции, либо после.
     *
     * В Java:
     * 1) Запись в поле типа boolean, byte, short, char, int, Object всегда атомарна
     * 2) Запись в поле типа long/double (64 bit): атомарна запись старших и младших 32 bit
     * 3) Запись в поле типа long/double, обьявленное volatile, отомарна
     *
     * Теоретически мы можем увидеть записанное на половину число в long/double (один поток пишет,
     * другой читает). В 64bit системе это невозможно.
     *
     *
     * Видимость (visibility)
     * 1) Результат операции write X, выполненное в потоке А, виден в операции read X, выполненной в потоке В
     * 2) Видимость определена только для конкретных потоков А и В, нет "глобальной видимости"
     *
     *
     * Happens Before
     * * A happens before B (A hb B), если все записи, выполненные до точки А (включительно), видный в любой операции
     * чтения после точки В (включительно)
     * * A hb B, B hb C -> A hb C
     * 1) Для двух операция А и В в одном потоке A hb B, если А раньше В в тексте программы (program order)
     * 2) Завершение конструктора X hb начало finalize X
     * 3) Вызов thread.start() hb первое действие в потоке thread
     * 4) Последнее действие в потоке thread hb thread.join()
     * 5) Инициализация обьекта по умолчания hb любое другое действие
     * 6) volatile write hb volatile read, который прочитал это значение
     *
     * Synchronized
     * 1) Между синхронизациями по одном обьекту установлен полный порядок (total order)
     * 2) Завершение сонхронизации (monitorexit) hb начало последующей синхронищации по тому же обьекту (monitorenter)
     *
     * Dead lock
     * Возникает при выполнении четырех условий
     * 1) Взаимное исключение (неразделяемые ресурсы)
     * 2) Минимум два ресурса (один держим, один просим)
     * 3) Ресурс освобожадется только добровольно тем, кто держит
     * 4) Напрравленый график ожидания имеет цикл



     */

}
